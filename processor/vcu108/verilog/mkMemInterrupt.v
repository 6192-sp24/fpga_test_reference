//
// Generated by Bluespec Compiler (build 7d25cde)
//
// timestamp removed
//
// BVI format method schedule info:
// schedule tlp_request_get  CF ( tlp_response_put,
// 			       interruptRequest_put,
// 			       interruptTrace_get );
// schedule tlp_request_get  C ( tlp_request_get );
//
// schedule tlp_response_put  CF ( tlp_request_get,
// 				tlp_response_put,
// 				interruptRequest_put,
// 				interruptTrace_get );
//
// schedule interruptRequest_put  CF ( tlp_request_get, tlp_response_put );
// schedule interruptRequest_put  SB ( interruptTrace_get );
// schedule interruptRequest_put  C ( interruptRequest_put );
//
// schedule interruptTrace_get  CF ( tlp_request_get, tlp_response_put );
// schedule interruptTrace_get  C ( interruptTrace_get );
//
//
// Ports:
// Name                         I/O  size props
// tlp_request_get                O   153 reg
// RDY_tlp_request_get            O     1 reg
// RDY_tlp_response_put           O     1 const
// RDY_interruptRequest_put       O     1 reg
// interruptTrace_get             O    96 reg
// RDY_interruptTrace_get         O     1 reg
// my_id                          I    16
// CLK                            I     1 clock
// RST_N                          I     1 reset
// tlp_response_put               I   153 unused
// interruptRequest_put           I    96
// EN_tlp_response_put            I     1 unused
// EN_interruptRequest_put        I     1
// EN_tlp_request_get             I     1
// EN_interruptTrace_get          I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkMemInterrupt(my_id,
		      CLK,
		      RST_N,

		      EN_tlp_request_get,
		      tlp_request_get,
		      RDY_tlp_request_get,

		      tlp_response_put,
		      EN_tlp_response_put,
		      RDY_tlp_response_put,

		      interruptRequest_put,
		      EN_interruptRequest_put,
		      RDY_interruptRequest_put,

		      EN_interruptTrace_get,
		      interruptTrace_get,
		      RDY_interruptTrace_get);
  input  [15 : 0] my_id;
  input  CLK;
  input  RST_N;

  // actionvalue method tlp_request_get
  input  EN_tlp_request_get;
  output [152 : 0] tlp_request_get;
  output RDY_tlp_request_get;

  // action method tlp_response_put
  input  [152 : 0] tlp_response_put;
  input  EN_tlp_response_put;
  output RDY_tlp_response_put;

  // action method interruptRequest_put
  input  [95 : 0] interruptRequest_put;
  input  EN_interruptRequest_put;
  output RDY_interruptRequest_put;

  // actionvalue method interruptTrace_get
  input  EN_interruptTrace_get;
  output [95 : 0] interruptTrace_get;
  output RDY_interruptTrace_get;

  // signals for module outputs
  wire [152 : 0] tlp_request_get;
  wire [95 : 0] interruptTrace_get;
  wire RDY_interruptRequest_put,
       RDY_interruptTrace_get,
       RDY_tlp_request_get,
       RDY_tlp_response_put;

  // register interruptSecondHalf
  reg [32 : 0] interruptSecondHalf;
  wire [32 : 0] interruptSecondHalf_D_IN;
  wire interruptSecondHalf_EN;

  // register tlpTag
  reg [7 : 0] tlpTag;
  wire [7 : 0] tlpTag_D_IN;
  wire tlpTag_EN;

  // ports of submodule interruptRequestFifo
  wire [97 : 0] interruptRequestFifo_D_IN, interruptRequestFifo_D_OUT;
  wire interruptRequestFifo_CLR,
       interruptRequestFifo_DEQ,
       interruptRequestFifo_EMPTY_N,
       interruptRequestFifo_ENQ,
       interruptRequestFifo_FULL_N;

  // ports of submodule interruptTraceFifo
  wire [97 : 0] interruptTraceFifo_D_IN, interruptTraceFifo_D_OUT;
  wire interruptTraceFifo_CLR,
       interruptTraceFifo_DEQ,
       interruptTraceFifo_EMPTY_N,
       interruptTraceFifo_ENQ,
       interruptTraceFifo_FULL_N;

  // ports of submodule tlpOutFifo
  wire [152 : 0] tlpOutFifo_D_IN, tlpOutFifo_D_OUT;
  wire tlpOutFifo_CLR,
       tlpOutFifo_DEQ,
       tlpOutFifo_EMPTY_N,
       tlpOutFifo_ENQ,
       tlpOutFifo_FULL_N;

  // rule scheduling signals
  wire WILL_FIRE_RL_interruptTlpOut;

  // inputs to muxes for submodule ports
  wire [152 : 0] MUX_tlpOutFifo_enq_1__VAL_1, MUX_tlpOutFifo_enq_1__VAL_2;
  wire [32 : 0] MUX_interruptSecondHalf_write_1__VAL_1;
  wire MUX_interruptSecondHalf_write_1__SEL_1,
       MUX_tlpOutFifo_enq_1__SEL_1,
       MUX_tlpOutFifo_enq_1__SEL_2;

  // remaining internal signals
  wire [127 : 0] x1_avValue_fst_data__h719,
		 x1_avValue_fst_data__h724,
		 x_data__h1876;
  wire [31 : 0] spliced_bits__h1899;

  // actionvalue method tlp_request_get
  assign tlp_request_get = tlpOutFifo_D_OUT ;
  assign RDY_tlp_request_get = tlpOutFifo_EMPTY_N ;

  // action method tlp_response_put
  assign RDY_tlp_response_put = 1'd1 ;

  // action method interruptRequest_put
  assign RDY_interruptRequest_put = interruptRequestFifo_FULL_N ;

  // actionvalue method interruptTrace_get
  assign interruptTrace_get = interruptTraceFifo_D_OUT[97:2] ;
  assign RDY_interruptTrace_get = interruptTraceFifo_EMPTY_N ;

  // submodule interruptRequestFifo
  FIFO2 #(.width(32'd98), .guarded(1'd1)) interruptRequestFifo(.RST(RST_N),
							       .CLK(CLK),
							       .D_IN(interruptRequestFifo_D_IN),
							       .ENQ(interruptRequestFifo_ENQ),
							       .DEQ(interruptRequestFifo_DEQ),
							       .CLR(interruptRequestFifo_CLR),
							       .D_OUT(interruptRequestFifo_D_OUT),
							       .FULL_N(interruptRequestFifo_FULL_N),
							       .EMPTY_N(interruptRequestFifo_EMPTY_N));

  // submodule interruptTraceFifo
  SizedFIFO #(.p1width(32'd98),
	      .p2depth(32'd4),
	      .p3cntr_width(32'd2),
	      .guarded(1'd1)) interruptTraceFifo(.RST(RST_N),
						 .CLK(CLK),
						 .D_IN(interruptTraceFifo_D_IN),
						 .ENQ(interruptTraceFifo_ENQ),
						 .DEQ(interruptTraceFifo_DEQ),
						 .CLR(interruptTraceFifo_CLR),
						 .D_OUT(interruptTraceFifo_D_OUT),
						 .FULL_N(interruptTraceFifo_FULL_N),
						 .EMPTY_N(interruptTraceFifo_EMPTY_N));

  // submodule tlpOutFifo
  SizedFIFO #(.p1width(32'd153),
	      .p2depth(32'd8),
	      .p3cntr_width(32'd3),
	      .guarded(1'd1)) tlpOutFifo(.RST(RST_N),
					 .CLK(CLK),
					 .D_IN(tlpOutFifo_D_IN),
					 .ENQ(tlpOutFifo_ENQ),
					 .DEQ(tlpOutFifo_DEQ),
					 .CLR(tlpOutFifo_CLR),
					 .D_OUT(tlpOutFifo_D_OUT),
					 .FULL_N(tlpOutFifo_FULL_N),
					 .EMPTY_N(tlpOutFifo_EMPTY_N));

  // rule RL_interruptTlpOut
  assign WILL_FIRE_RL_interruptTlpOut =
	     interruptRequestFifo_EMPTY_N &&
	     (interruptRequestFifo_D_OUT[1] &&
	      interruptRequestFifo_D_OUT[0] ||
	      tlpOutFifo_FULL_N) &&
	     !interruptSecondHalf[32] ;

  // inputs to muxes for submodule ports
  assign MUX_interruptSecondHalf_write_1__SEL_1 =
	     WILL_FIRE_RL_interruptTlpOut && !interruptRequestFifo_D_OUT[1] ;
  assign MUX_tlpOutFifo_enq_1__SEL_1 =
	     WILL_FIRE_RL_interruptTlpOut &&
	     (!interruptRequestFifo_D_OUT[1] ||
	      !interruptRequestFifo_D_OUT[0]) ;
  assign MUX_tlpOutFifo_enq_1__SEL_2 =
	     interruptRequestFifo_EMPTY_N && tlpOutFifo_FULL_N &&
	     interruptSecondHalf[32] ;
  assign MUX_interruptSecondHalf_write_1__VAL_1 =
	     { 1'd1, interruptRequestFifo_D_OUT[33:2] } ;
  assign MUX_tlpOutFifo_enq_1__VAL_1 =
	     { 1'd1,
	       interruptRequestFifo_D_OUT[1],
	       23'd65535,
	       x1_avValue_fst_data__h724 } ;
  assign MUX_tlpOutFifo_enq_1__VAL_2 = { 25'd8450048, x_data__h1876 } ;

  // register interruptSecondHalf
  assign interruptSecondHalf_D_IN =
	     MUX_interruptSecondHalf_write_1__SEL_1 ?
	       MUX_interruptSecondHalf_write_1__VAL_1 :
	       33'h0AAAAAAAA ;
  assign interruptSecondHalf_EN =
	     WILL_FIRE_RL_interruptTlpOut && !interruptRequestFifo_D_OUT[1] ||
	     MUX_tlpOutFifo_enq_1__SEL_2 ;

  // register tlpTag
  assign tlpTag_D_IN = 8'h0 ;
  assign tlpTag_EN = 1'b0 ;

  // submodule interruptRequestFifo
  assign interruptRequestFifo_D_IN =
	     { interruptRequest_put,
	       interruptRequest_put[95:64] == 32'd0,
	       interruptRequest_put[63:32] == 32'd0 } ;
  assign interruptRequestFifo_ENQ = EN_interruptRequest_put ;
  assign interruptRequestFifo_DEQ =
	     WILL_FIRE_RL_interruptTlpOut && interruptRequestFifo_D_OUT[1] ||
	     MUX_tlpOutFifo_enq_1__SEL_2 ;
  assign interruptRequestFifo_CLR = 1'b0 ;

  // submodule interruptTraceFifo
  assign interruptTraceFifo_D_IN =
	     { interruptRequest_put,
	       interruptRequest_put[95:64] == 32'd0,
	       interruptRequest_put[63:32] == 32'd0 } ;
  assign interruptTraceFifo_ENQ =
	     EN_interruptRequest_put && interruptTraceFifo_FULL_N ;
  assign interruptTraceFifo_DEQ = EN_interruptTrace_get ;
  assign interruptTraceFifo_CLR = 1'b0 ;

  // submodule tlpOutFifo
  assign tlpOutFifo_D_IN =
	     MUX_tlpOutFifo_enq_1__SEL_1 ?
	       MUX_tlpOutFifo_enq_1__VAL_1 :
	       MUX_tlpOutFifo_enq_1__VAL_2 ;
  assign tlpOutFifo_ENQ =
	     WILL_FIRE_RL_interruptTlpOut &&
	     (!interruptRequestFifo_D_OUT[1] ||
	      !interruptRequestFifo_D_OUT[0]) ||
	     MUX_tlpOutFifo_enq_1__SEL_2 ;
  assign tlpOutFifo_DEQ = EN_tlp_request_get ;
  assign tlpOutFifo_CLR = 1'b0 ;

  // remaining internal signals
  assign spliced_bits__h1899 =
	     { interruptSecondHalf[7:0],
	       interruptSecondHalf[15:8],
	       interruptSecondHalf[23:16],
	       interruptSecondHalf[31:24] } ;
  assign x1_avValue_fst_data__h719 =
	     { interruptRequestFifo_D_OUT[1] ?
		 32'd1073745921 :
		 32'd1610612737,
	       my_id,
	       tlpTag,
	       8'd15,
	       interruptRequestFifo_D_OUT[1] ?
		 { interruptRequestFifo_D_OUT[65:36],
		   2'd0,
		   interruptRequestFifo_D_OUT[9:2],
		   interruptRequestFifo_D_OUT[17:10],
		   interruptRequestFifo_D_OUT[25:18],
		   interruptRequestFifo_D_OUT[33:26] } :
		 { 24'd0, interruptRequestFifo_D_OUT[73:36], 2'd0 } } ;
  assign x1_avValue_fst_data__h724 =
	     (interruptRequestFifo_D_OUT[1] &&
	      interruptRequestFifo_D_OUT[0]) ?
	       128'd0 :
	       x1_avValue_fst_data__h719 ;
  assign x_data__h1876 = { spliced_bits__h1899, 96'd0 } ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        interruptSecondHalf <= `BSV_ASSIGNMENT_DELAY 33'h0AAAAAAAA;
	tlpTag <= `BSV_ASSIGNMENT_DELAY 8'd0;
      end
    else
      begin
        if (interruptSecondHalf_EN)
	  interruptSecondHalf <= `BSV_ASSIGNMENT_DELAY
	      interruptSecondHalf_D_IN;
	if (tlpTag_EN) tlpTag <= `BSV_ASSIGNMENT_DELAY tlpTag_D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    interruptSecondHalf = 33'h0AAAAAAAA;
    tlpTag = 8'hAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkMemInterrupt

